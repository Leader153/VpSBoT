# 🔍 Анализ архитектуры проекта Gemini_whatsUP

## 📋 Структура проекта

```
Gemini_whatsUP/
├── index.js                    # Точка входа (запускает answer_phone.js)
├── .env                        # Переменные окружения
├── package.json                # Зависимости
│
├── handlers/                   # HTTP обработчики
│   ├── answer_phone.js         # Основной сервер (HTTP + WebSocket)
│   ├── mediaStreamHandler.js    # WebSocket обработчик для Twilio Media Streams
│   └── messaging_handler.js    # WhatsApp/SMS обработчик
│
├── utils/                      # Утилиты
│   ├── conversationEngine.js   # Обычная обработка сообщений (без streaming)
│   ├── streamingEngine.js      # Потоковая обработка (с streaming)
│   ├── crmService.js           # Работа с CRM
│   ├── messageFormatter.js     # Форматирование сообщений
│   ├── messagingService.js     # Отправка WhatsApp сообщений
│   ├── emailService.js         # Отправка email
│   └── fileUtils.js            # Работа с файлами
│
├── memory/                     # Управление сессиями
│   └── sessionManager.js       # Хранение истории диалогов
│
├── rag/                        # RAG система (Retrieval-Augmented Generation)
│   ├── retriever.js            # Поиск контекста из базы знаний
│   ├── vectorStore.js          # Работа с ChromaDB
│   └── loadDocuments.js        # Загрузка документов в ChromaDB
│
├── calendar/                   # Интеграция с Google Calendar
│   └── calendarTools.js        # Инструменты для работы с календарём
│
├── data/                       # Данные и конфигурация
│   └── botBehavior.js          # Настройки бота, промпты, голоса
│
└── public/                     # Статические файлы
    └── music/                  # Музыка на удержании (сейчас не используется)
```

---

## 🔄 Как работает проект (2 режима)

### Режим 1: Обычный (без streaming) - `/voice`

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Twilio звонит на /voice                                  │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. answer_phone.js: /voice                                  │
│    - Приветствие через TTS                                  │
│    - <Gather> для распознавания речи                        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Twilio распознаёт речь → /respond                        │
│    - Получает SpeechResult                                  │
│    - Запускает conversationEngine.processMessage() в фоне   │
│    - Сохраняет в pendingAITasks                             │
│    - Редирект на /check_ai                                  │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. /check_ai (polling каждые 100ms)                         │
│    - Проверяет готовность ответа от Gemini                  │
│    - Если не готово: пауза 1 сек + редирект на /check_ai    │
│    - Если готово: говорит ответ через TTS                   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. conversationEngine.processMessage()                      │
│    ├── RAG: getContextForPrompt() (ChromaDB)                │
│    ├── CRM: getCustomerData()                               │
│    ├── Gemini: generateContent() ← ЖДЁТ ВЕСЬ ОТВЕТ          │
│    └── Возвращает полный текст                              │
└─────────────────────────────────────────────────────────────┘
```

**Проблема:** Задержка ~9 секунд (ждём полный ответ от Gemini)

---

### Режим 2: Streaming (потоковый) - `/voice-stream` ⚡

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Twilio звонит на /voice-stream                           │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. answer_phone.js: /voice-stream                           │
│    - <Connect><Stream url="wss://api.../ws">                │
│    - Открывает WebSocket соединение                         │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. mediaStreamHandler.js (WebSocket)                        │
│    - Получает событие 'start'                               │
│    - Сохраняет соединение в activeStreams                   │
│    - Отправляет приветствие через TTS                       │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Twilio распознаёт речь → /stream-message                 │
│    - Получает SpeechResult                                  │
│    - Вызывает mediaStreamHandler.handleUserMessage()        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. streamingEngine.processMessageStream()                   │
│    ├── RAG: getContextForPrompt() (ChromaDB)                │
│    ├── CRM: getCustomerData()                               │
│    ├── Gemini: generateContentStream() ← ПОТОКОВАЯ ГЕНЕРАЦИЯ│
│    │   ├── Первый чанк (2-3 слова) → onChunk() → TTS        │
│    │   ├── Второй чанк → onChunk() → TTS                    │
│    │   └── ... продолжает отправлять по мере генерации      │
│    └── onComplete() - завершение генерации                  │
└─────────────────────────────────────────────────────────────┘
```

**Преимущество:** Задержка ~0.5-1 секунда (начинаем говорить после первых слов)

---

## 📊 Сравнение режимов

| Параметр | Обычный режим | Streaming режим |
|----------|---------------|-----------------|
| **Эндпоинт** | `/voice` | `/voice-stream` |
| **Технология** | HTTP + TwiML | WebSocket + Media Streams |
| **Gemini API** | `generateContent()` | `generateContentStream()` |
| **First Token** | ~9 секунд | ~0.5 секунды ⚡ |
| **Total Time** | ~9 секунд | ~1-2 секунды |
| **UX** | Долгая тишина | Естественный диалог |
| **Модуль** | `conversationEngine.js` | `streamingEngine.js` |

---

## 🔧 Ключевые компоненты

### 1. `answer_phone.js` (Основной сервер)

**Роль:** HTTP/HTTPS сервер + WebSocket сервер

**Эндпоинты:**

#### Обычный режим:
- `POST /voice` - начало звонка
- `POST /respond` - обработка распознанной речи
- `POST /check_ai` - проверка готовности ответа (polling)
- `POST /process_tool` - выполнение функций (календарь, WhatsApp)
- `POST /handle-dial-status` - обработка перевода на оператора
- `POST /reprompt` - обработка тишины

#### Streaming режим:
- `POST /voice-stream` - начало потокового звонка
- `POST /stream-message` - обработка распознанной речи в streaming режиме
- `WebSocket /ws` - двунаправленная потоковая передача

**Запуск:**
```javascript
// HTTP/HTTPS сервер на порту 1337
httpServer.listen(port);

// WebSocket на том же сервере по пути /ws
const wss = new WebSocket.Server({ 
    server: httpServer,
    path: '/ws'
});
```

---

### 2. `conversationEngine.js` (Обычная обработка)

**Роль:** Обработка сообщений БЕЗ потоковой передачи

**Основная функция:**
```javascript
async processMessage(userMessage, sessionId, channel, userPhone)
```

**Что делает:**
1. Параллельно запускает RAG + CRM
2. Формирует системный промпт
3. Отправляет в Gemini: `generateContent()` ← ЖДЁТ ВЕСЬ ОТВЕТ
4. Возвращает полный текст

**Используется для:**
- Голосовой канал (обычный режим)
- WhatsApp
- SMS

---

### 3. `streamingEngine.js` (Потоковая обработка) ⚡

**Роль:** Обработка сообщений С потоковой передачей

**Основная функция:**
```javascript
async processMessageStream(userMessage, sessionId, userPhone, onChunk, onComplete, onError)
```

**Что делает:**
1. Параллельно запускает RAG + CRM
2. Формирует системный промпт
3. Отправляет в Gemini: `generateContentStream()` ← ПОТОКОВАЯ ГЕНЕРАЦИЯ
4. Для каждого чанка вызывает `onChunk(text)` → отправка в TTS
5. По завершению вызывает `onComplete(result)`

**Ключевая логика:**
```javascript
for await (const chunk of result.stream) {
    const chunkText = chunk.text();
    fullText += chunkText;
    wordBuffer += chunkText;
    
    // Отправляем порциями по 3 слова
    if (words.length >= 3) {
        onChunk(textToSend); // → TTS сразу!
    }
}
```

**Используется для:**
- Голосовой канал (streaming режим)

---

### 4. `mediaStreamHandler.js` (WebSocket обработчик)

**Роль:** Управление WebSocket соединениями с Twilio

**События WebSocket:**
- `start` - начало стрима (сохраняет соединение)
- `media` - получение аудио данных (пока не используется)
- `stop` - остановка стрима

**Основная функция:**
```javascript
async handleUserMessage(callSid, userMessage, userPhone)
```

**Что делает:**
1. Находит активное WebSocket соединение по CallSid
2. Запускает `streamingEngine.processMessageStream()`
3. Для каждого чанка вызывает `sendTTS()` → отправка в Twilio

---

### 5. `sessionManager.js` (Управление сессиями)

**Роль:** Хранение истории диалогов в памяти

**Данные по сессии:**
```javascript
{
    channel: 'voice',
    history: [...],  // История сообщений для Gemini
    gender: 'male',  // Пол клиента
    userPhone: '+972...',
    pendingFunctionCalls: {...}  // Ожидающие вызовы функций
}
```

---

### 6. RAG система (retriever.js + vectorStore.js)

**Роль:** Поиск релевантного контекста из базы знаний

**Как работает:**
```javascript
getContextForPrompt(userMessage, topK=3)
```

1. Подключается к ChromaDB (localhost:8000)
2. Ищет похожие документы по запросу
3. Возвращает топ-3 релевантных фрагмента
4. Контекст добавляется в системный промпт для Gemini

**База знаний:**
- `data/products_knowledge_base.csv` - информация о продуктах
- `data/*.txt` - дополнительные документы

---

## 🌐 Работа через Cloudflare

```
┌──────────────────────────────────────────────────────────┐
│ Интернет                                                 │
│ (Twilio, пользователи)                                   │
└────────────────────┬─────────────────────────────────────┘
                     │
                     │ HTTPS/WSS (порт 443)
                     ▼
┌──────────────────────────────────────────────────────────┐
│ Cloudflare                                               │
│ - SSL сертификат                                         │
│ - DDoS защита                                            │
│ - Кеширование                                            │
│ - WebSocket проксирование                                │
└────────────────────┬─────────────────────────────────────┘
                     │
                     │ Проксирует на внутренний порт
                     ▼
┌──────────────────────────────────────────────────────────┐
│ Ваш сервер (api.leadertechnology.shop)                   │
│                                                          │
│ Node.js приложение на порту 1337                         │
│ ├── HTTP/HTTPS сервер                                    │
│ │   ├── /voice                                           │
│ │   ├── /voice-stream                                    │
│ │   ├── /respond                                         │
│ │   └── ...                                              │
│ │                                                        │
│ └── WebSocket сервер                                     │
│     └── /ws                                              │
└──────────────────────────────────────────────────────────┘
```

**Важно:**
- Снаружи все видят порт **443** (стандартный HTTPS)
- Внутри приложение работает на порту **1337**
- WebSocket доступен по пути `/ws` (не на отдельном порту!)
- Cloudflare автоматически проксирует WebSocket

---

## 🚀 Запуск проекта

```bash
# 1. Установка зависимостей
npm install

# 2. Запуск
npm start
# или
node index.js
```

**Что происходит при запуске:**

1. `index.js` загружает `.env`
2. Устанавливает обработчики ошибок
3. Запускает `handlers/answer_phone.js`
4. `answer_phone.js` создаёт:
   - HTTP/HTTPS сервер на порту 1337
   - WebSocket сервер на пути `/ws`
   - Все эндпоинты для обработки звонков

**Логи при успешном запуске:**
```
✅ TwiML HTTPS server running for domain api.leadertechnology.shop on port 1337
🔌 WebSocket сервер запущен на api.leadertechnology.shop/ws (через Cloudflare)
```

---

## 📝 Выводы

### ✅ Что работает хорошо:
1. **Модульная архитектура** - чёткое разделение ответственности
2. **Два режима работы** - обычный и streaming
3. **RAG система** - контекст из базы знаний
4. **Интеграция с Cloudflare** - безопасность и производительность
5. **Управление сессиями** - сохранение истории диалогов
6. **Обработка ошибок** - логирование в файл

### ⚠️ Что нужно доработать:
1. **TTS интеграция в streaming режиме** - сейчас только концепция
2. **Обработка аудио потоков** - WebSocket получает аудио, но не обрабатывает
3. **Тестирование streaming режима** - нужно протестировать с реальными звонками

### 🎯 Рекомендации:
1. Протестировать оба режима
2. Сравнить задержку
3. При успехе streaming режима - переключить все звонки на `/voice-stream`
